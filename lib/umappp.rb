# frozen_string_literal: true

require "numo/narray"
require_relative "umappp/version"
require_relative "umappp/umappp"

# Uniform Manifold Approximation and Projection
module Umappp
  # Make wrapper methods for the C++ function generated by Rice private
  private_class_method :umappp_run
  private_class_method :umappp_default_parameters

  # View the default parameters defined within the Umappp C++ library structure.
  def self.default_parameters
    # {method: :annoy, ndim: 2}.merge
    umappp_default_parameters
  end

  # Runs the Uniform Manifold Approximation and Projection (UMAP) dimensional
  # reduction technique.
  # @param embedding [Array, Numo::SFloat]
  # @param method [Symbol]
  # @param ndim [Integer]
  # @param tick [Integer]
  # @param local_connectivity [Numeric]
  # @param bandwidth [Numeric]
  # @param mix_ratio [Numeric]
  # @param spread [Numeric]
  # @param min_dist [Numeric]
  # @param a [Numeric]
  # @param b [Numeric]
  # @param repulsion_strength [Numeric]
  # @param initialize [Umappp::InitMethod]
  # @param num_epochs [Integer]
  # @param learning_rate [Numeric]
  # @param negative_sample_rate [Numeric]
  # @param num_neighbors [Integer]
  # @param seed [Integer]
  # @param num_threads [Integer]
  # @param parallel_optimization [Boolean]
  # @return [Numo::SFloat] the final embedding

  def self.run(embedding, method: :annoy, ndim: 2, **params)
    unless (u = (params.keys - default_parameters.keys)).empty?
      raise ArgumentError, "[umappp.rb] unknown option : #{u.inspect}"
    end

    nnmethod = %i[annoy vptree].index(method.to_sym)
    raise ArgumentError, "method must be :annoy or :vptree" if nnmethod.nil?

    embedding2 = Numo::SFloat.cast(embedding)
    raise ArgumentError, "embedding must be a 2D array" if embedding2.ndim <= 1
    raise ArgumentError, "embedding must not be empty" if embedding2.size.zero?

    umappp_run(params, embedding2, ndim, nnmethod)
  end
end
