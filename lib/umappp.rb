# frozen_string_literal: true

require "numo/narray"
require_relative "umappp/version"
require_relative "umappp/umappp"

# Uniform Manifold Approximation and Projection
module Umappp
  # Make wrapper methods for the C++ function generated by Rice private
  private_class_method :umappp_run
  private_class_method :umappp_default_parameters

  # View the default parameters defined within the Umappp C++ library structure.
  def self.default_parameters
    # {method: :annoy, ndim: 2}.merge
    umappp_default_parameters
  end

  # Runs the Uniform Manifold Approximation and Projection (UMAP) dimensional
  # reduction technique.
  # @param embedding [Array, Numo::SFloat]
  # @param method [Symbol, String]
  # @param ndim [Integer]
  # @param tick [Integer]
  # @param local_connectivity [Numeric]
  # @param bandwidth [Numeric]
  # @param mix_ratio [Numeric]
  # @param spread [Numeric]
  # @param min_dist [Numeric]
  # @param a [Numeric]
  # @param b [Numeric]
  # @param repulsion_strength [Numeric]
  # @param initialize [Symbol, Umappp::InitMethod]
  # @param num_epochs [Integer]
  # @param learning_rate [Numeric]
  # @param negative_sample_rate [Numeric]
  # @param num_neighbors [Integer]
  # @param seed [Integer]
  # @param num_threads [Integer]
  # @param parallel_optimization [Boolean]
  # @return [Numo::SFloat] the final embedding

  def self.run(embedding, method: :annoy, ndim: 2, **params)
    unless (u = (params.keys - default_parameters.keys)).empty?
      raise ArgumentError, "[umappp.rb] unknown option : #{u.inspect}"
    end

    nnmethod = %i[annoy vptree].index(method.to_sym)
    raise ArgumentError, "method must be :annoy or :vptree" if nnmethod.nil?

    # Allow initialize: to be specified as a Symbol or String and
    # convert it to the corresponding Umappp::InitMethod enum.
    if params.key?(:initialize)
      init_val = params[:initialize]

      if init_val.is_a?(Symbol) || init_val.is_a?(String)
        init_sym = init_val.to_sym
        mapping = {
          spectral: InitMethod::SPECTRAL,
          spectral_only: InitMethod::SPECTRAL_ONLY,
          random: InitMethod::RANDOM,
          none: InitMethod::NONE
        }

        mapped = mapping[init_sym]
        unless mapped
          raise ArgumentError,
                "initialize must be one of :spectral, :spectral_only, :random, :none or a Umappp::InitMethod"
        end

        params[:initialize] = mapped
      end
      # If it's already a Umappp::InitMethod, we just pass it through.
    end

    embedding2 = Numo::SFloat.cast(embedding)
    raise ArgumentError, "embedding must be a 2D array" if embedding2.ndim <= 1
    raise ArgumentError, "embedding must not be empty" if embedding2.size.zero?

    umappp_run(params, embedding2, ndim, nnmethod)
  end
end
